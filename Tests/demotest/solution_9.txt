I. Остаточные вычисления и CPS

Остаточные вычисления (continuations) в Scheme Racket позволяют захватывать и управлять состоянием выполнения программы, представляя "будущее" вычислений как объект. Например, в выражении (* (+ 2 3) 4) подвыражение (+ 2 3) имеет остаток (* [] 4), где результат (+ 2 3) подставляется в остаток для завершения вычисления. Это даёт возможность явно контролировать порядок выполнения.
Стиль передачи продолжений (CPS) в Racket преобразует функции так, что они не возвращают результат напрямую, а передают его в функцию-продолжение, указывающую, что делать дальше.

Пример — функция taskIII-cps:
(define (taskIII-cps t s cc)
  (cond
    ((equal? t 1) (cc s))
    ((equal? t 0) (cc 0))
    (else
      (let ((s/4 (/ s 4)))
        (taskIII-cps (vector-ref t 0) s/4
          (lambda (area0)
            (taskIII-cps (vector-ref t 1) s/4
              (lambda (area1)
                (taskIII-cps (vector-ref t 2) s/4
                  (lambda (area2)
                    (taskIII-cps (vector-ref t 3) s/4
                      (lambda (area3)
                        (cc (+ area0 area1 area2 area3))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
)

Функция taskIII-cps вычисляет площадь дерева t с параметром s, передавая результат в продолжение cc. Для листа t = 1 она вызывает cc с s, для t = 0 — с нулем. Если t — вектор, делит s на 4 и рекурсивно обрабатывает четыре поддерева, передавая каждому s/4 и лямбда-функцию как продолжение. Эти лямбда-функции собирают площади поддеревьев и суммируют их, вызывая cc с итогом. Все вызовы хвостовые, что оптимизирует стек, а CPS управляет потоком выполнения.

CPS позволяет: 
1) управлять потоком выполнения (например, менять cc для обработки результатов)
2) поддерживать хвостовую рекурсию, экономя стек
3) моделировать сложные процессы, как потоки данных


III. Мемоизация

Мемоизация — это оптимизация, при которой результаты вызовов функции сохраняются в кэше, чтобы избежать повторных вычислений для одинаковых аргументов. В Racket это реализуется с помощью хэш-таблицы.
Пример — taskV:

(define taskV
  (let ((cache (make-hash)))
    (lambda (n)
      (cond
        ((< n 1) (error "n должно быть положительным"))
        ((hash-ref cache n #f) => identity)
        (else
          (let loop ((k 2) (count 0) (primes '()))
            (if (>= count n)
              (let ((result (car primes)))
               (hash-set! cache n result)
               result
              )
              (let ((candidate (sub1 (expt 2 k))))
                (if (is-prime? candidate)
                  (loop (+ k 1) (+ count 1) (cons candidate primes))
                  (loop (+ k 1) count primes)
                )
              )
            )
          )
        )
      )
    )
  )
)

Мемоизация в функции taskV реализована через хэш-таблицу cache, которая хранит результаты для входного n. При вызове функции проверяется, есть ли результат в cache для n. Если есть, он возвращается сразу. Если нет, функция вычисляет n-е простое число Мерсенна, сохраняет его в cache и возвращает. Это ускоряет повторные вызовы с тем же n, но бесполезно при уникальных входных данных, так как кэш не используется.

Мемоизация оправдана, если: 
1) функция чистая (одинаковый вход даёт одинаковый выход)
2) вычисления затратны, как в рекурсии Фибоначчи
3) аргументы часто повторяются. Это идеально для динамического программирования или рекурсивных алгоритмов

Мемоизация неуместна, когда: 
1) входные данные уникальны, и кэш не используется
2) функция имеет побочные эффекты, что делает кэширование ненадёжным
3) память ограничена, а кэш растёт. 

Пример неоправданной мемоизации:
(define (generate-id)
  (current-milliseconds))

(define generate-id-memo
  (let ([cache (make-hash)])
    (lambda ()
      (hash-ref! cache 'id
                 (lambda () (generate-id)))
    )
  )
)

Если вызвать generate-id-memo в первый раз, она вернёт текущее время, например, 1634567890123, и сохранит его в кэше. Однако при каждом следующем вызове функция будет возвращаться тот же самый результат (1634567890123), независимо от того, сколько времени прошло. Это полностью ломает логику генерации уникальных идентификаторов, так как ожидается, что каждый вызов будет возвращать новое значение, основанное на текущем времени.

Мемоизация предполагает, что результат функции зависит только от её входных данных (в данном случае их нет) и не изменяется со временем. Однако generate-id зависит от внешнего состояния — текущего времени, которое постоянно меняется. Кэширование фиксирует первое значение и делает функцию бесполезной для генерации новых идентификаторов.
