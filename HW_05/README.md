## Условие

### Perfect binary tree

Опишите функцию `(task-5 tree h)`, проверяет, является ли двоичное дерево tree совершенным деревом высоты ***h***. Положим, что пустое дерево является совершенным деревом высоты ***0***, дерево из одного листа -- совершенное дерево высоты ***1***, дерево из корня, у которого левое поддерево является совершенным деревом высоты ***1***, а правое -- совершенным деревом высоты ***1*** -- совершенным деревом высоты ***2*** и т. д. (левый потомок ровно той же высоты, что и правый и оба -- совершенные деревья.

В решении используйте функции работы с деревьями, введённые на лекции, реализующие векторное представление дерева. С помощью ***call/cc*** добейтесь эффективного решения, чтобы #f возвращалось сразу, как только становится ясно, что дерево не совершенное и/или не той высоты. 

Примеры:
```
> (task-5 #() 0) -> #t
> (task-5 #(1 #() #()) 1) -> #t
> (task-5 #() 1) -> #f
```

### Check fun-p is true for all tree

Опишите функцию `(for-all-tree fun-p tree)`, используя только хвостовую рекурсию (фактически, нужно использовать вспомогательное описание в стиле передачи продолжений). Функция получает двоичное дерево в векторном представлении и проверяет, что функция ***fun-p*** не даёт ложь ни на одном значении при всех вершинах дерева. 

Примеры:
```
> (for-all-tree odd? #()) -> #t
> (for-all-tree odd? #(1 #() #())) -> #t
> (for-all-tree odd? #(2 #() #())) -> #f
> (for-all-tree odd? #(3 #(1 #() #()) #(5 #() #()))) -> #t
```
