1) Реализация left-rot! функцией

В Racket и в Scheme в целом функции не могут изменять значения переменных, переданных в качестве аргументов, потому что аргументы передаются по значению, а не по ссылке. Функции могут возвращать новые значения, но не могут изменять существующие привязки переменных, поэтому реализовать left-rot! как функцию невозможно, потому что функция не имеет доступа к исходным переменным (именам) m0, m1, ..., mN — она получает только их значения.

2) Реализация left-rot! макросом
#lang racket

(define-syntax left-rot!
  (syntax-rules ()
    ((left-rot! m0 m1 ...)
      (let ([tmp m0])
        (shift-left! (m0 m1 ...) (m1 ... tmp))
      )
    )
  )
)

(define-syntax shift-left!
  (syntax-rules ()
    ((shift-left! () ()) (void))
    ((shift-left! (x) (y)) (set! x y))
    ((shift-left! (x xs ...) (y ys ...))
      (begin
        (set! x y)
        (shift-left! (xs ...) (ys ...))
      )
    )
  )
)

(let ((a 3) (b 2) (c 1)) (begin (left-rot! a b c) (/ a b c))) ; => 2/3

3) Какая реализация уместнее?
Макрос — единственный способ реализовать данное поведение функции в Racket.
