## Первый блок. Упражнения с 1 по 4

### Упражнение 1. Заготовка doctor.rkt

Запустите IDE Racket и откройте заготовку кода «Доктора». Запустите код в интерпретаторе (Ctrl+R или кнопкой Run). Проверьте, как он работает. Например, вводите реплики пациента из листинга (реплики отмечены **, но ** не являются частью реплик):
```
> (visit-doctor 'ivan)
Hello, ivan!
(what seems to be the trouble?)
**(everyone hates me)
(you feel that everyone hates you)
**(whenever i enter a room no one will look me in the eye)
(please go on)
**(they laugh at me behind my back)
(you seem to think they laugh at you behind your back)
**(they get together and talk about how they hate me)
(please continue)
**(even my mother hates me)
( that even your mother hates you)
**(even when i was a baby she said i was ugly and stupid)
(many people have the same sorts of feelings)
**(she hit me all the time)
(please continue)
...
```

«Доктор» отвечает на реплики пациента двумя способами, реализованными в нём. Первый способ заключается в замене в реплике пользователя всех местоимений первого лица *(i, me, my, ...)* на соответствующие местоимения второго лица *(you, you, are, ...)*. Местоимения второго лица в реплике пользователя заменяются на местоимения первого. К полученной таким образом фразе спереди дописывается некоторое общее замечание, вроде *"why do you say that или you seem to think that"*.

Второй способ проще первого. Реплика пациента при построении ответа не используется. В качестве ответа «Доктор» выдаёт одну из заготовленных общих фраз, выбранную случайно: *"please continue или many people have the same sorts of feelings"*.

Какой из двух методов будет использован, решает случай. С равной вероятностью выбирается один из двух.

«Доктор» запускается вызовом его основной функции -- ***visit-doctor*** с указанием имени пациента в качестве значения параметра. В этой функции сначала выводится приветствие пациента, задаётся вопрос, приглашающий к обмену репликами, а затем вызывается функция ***doctor-driver-loop***, реализующая цикл приёма реплик пациента и генерации ответов «Доктора».
```
(define (visit-doctor name)
  (printf "Hello, ~a!\n" name)
  (print '(what seems to be the trouble?))
  (doctor-driver-loop name)
)
```

В цикле происходит печать приглашения -- ** -- и чтение реплик пациента, каждая из которых является списком символов (пользователю следует вводить их в скобках). Если пациент говорит *(goodbye)*, происходит выход из цикла и завершение работы «Доктора». В противном случае, порождается ответная реплика в соответствии с одной из двух стратегий, описанных выше.
```
(define (doctor-driver-loop name)
    (newline)
    (print '**) ; доктор ждёт ввода реплики пациента, приглашением к которому является **
    (let ((user-response (read)))
      (cond 
	    ((equal? user-response '(goodbye)) ; реплика '(goodbye) служит для выхода из цикла
             (printf "Goodbye, ~a!\n" name)
             (print '(see you next week)))
            (else (print (reply user-response)) ; иначе Доктор генерирует ответ, печатает его и продолжает цикл
                  (doctor-driver-loop name)
             )
       )
     )
)
```

Генерацию ответной реплики осуществляет функция ***reply***, принимающая реплику пациента в качестве значения параметра.
```
(define (reply user-response)
      (case (random 0 2)  ; с равной вероятностью выбирается один из двух способов построения ответа
          ((0) (hedge-answer))  ; 1й способ
          ((1) (qualifier-answer user-response)) ; 2й способ  
      )
)
```

Первая стратегия построения ответов реализована функцией ***hedge-answer***. Она случайно выбирает из вектора заготовленных реплик один элемент.
```
(define (hedge-answer)
       (pick-random-vector '#((please go on)
                              (many people have the same sorts of feelings)
                              (many of my patients have told me the same thing)
                              (please continue))
         )
)
```

Вторая стратегия построения ответов реализована функцией ***qualifier-answer***, получающей реплику пациента в качестве значения параметра. В ней случайно выбирается одно из заготовленных начал ответа. Окончанием ответа является реплика пользователя, в которой заменены лица.
```
(define (qualifier-answer user-response)
        (append (pick-random-vector '#((you seem to think that)
                                       (you feel that)
                                       (why do you believe that)
                                       (why do you say that))
                )
                (change-person user-response)
        )
 )
```

Случайный выбор одного из элементов вектора реализует функция ***pick-random-vector***.
```
(define (pick-random-vector vctr)
  (vector-ref vctr (random 0 (vector-length vctr)))
)
```

Замену лиц осуществляет функция ***change-person***. Она вызывает более универсальную функцию ***many-replace***, получающую список замен и список, в котором следует произвести замены. Она проверяет каждый элемент изменяемого списка, на возможность его замены. Если замена возможна (элемент найден в списке замен, то она производится, а окончание ответа находится при помощи рекурсивного вызова. Список замен является ассоциативным списком. Он составлен из подсписков, каждый из которых начинается с элемента-ключа и продолжается элементом-значением. Поиск подсписка по ключу выполняет стандартная функция ***assoc***. Обратите внимание, что в ***if*** используется результат вызова ***assoc***, который не всегда будет логическим значением. Убедитесь, что Вы верно понимаете как работают ***if*** и ***assoc***.
```
(define (many-replace replacement-pairs lst)
        (cond ((null? lst) lst)
              (else (let ((pat-rep (assoc (car lst) replacement-pairs))) ; Доктор ищет первый элемент списка в ассоциативном списке замен
                      (cons (if pat-rep (cadr pat-rep) ; если поиск был удачен, то в начало ответа Доктор пишет замену
                                (car lst) ; иначе в начале ответа помещается начало списка без изменений
                            )
                            (many-replace replacement-pairs (cdr lst)) ; рекурсивно производятся замены в хвосте списка
                        )
                     )
               )
         )
)
```

#### Задание упражнения 1. 
Измените функции ***hedge*** и ***qualifier-answer***, добавив в каждую не менее трёх новых заготовленных фраз-реплик и/или фраз, с которых начинается ответ с заменой лица.

### Упражнение 2. Рекурсивные и итеративные процессы

Рассмотрим код функции ***many-replace***. В ней с рекурсивным вызовом связаны остаточные вычисления. Следовательно, процесс, порождаемый при вычислении вызова этой функции, -- рекурсивный. Можно переписать ***many-replace*** так, чтобы процесс стал итеративным и вычисления занимали меньше памяти за счёт хвостовой рекурсии.

#### Задание упражнения 2. 
Напишите новую версию функции ***many-replace-v2*** с хвостовой рекурсией и вызовите её в теле change-person. Составьте код нового ***many-replace-v2*** без определения локальной вспомогательной функции, а с использованием ***"именованного" let***. Далее всякий раз, когда для реализации итеративного процесса понадобится локальная вспомогательная функция, используйте вместо неё ***"именованный" let***. Новая версия функции должна быть эффективной. Если Вы планируете использовать append для "сборки" результата, то оцените сложность решения. Составьте эффектвное решение ***без append***.

### Упражнение 3. Функции высших порядков и списки

Рассмотрим ещё раз реализацию ***many-replace***. Она осуществляет отображение списка ***lst*** в список-результат. Общую схему подобной обработки списка реализует функция map.

#### Задание упражнения 3. 
Напишите ещё одну версию функции ***many-replace-v3*** и замените вызов в теле change-person. Сделайте так, чтобы тело новой версии состояло только из вызова ***map***. Дополнительную функцию не определяйте отдельно, а заведите как анонимную -- результат вычисления ***спецформы lambda***. Переписанная функция должна быть столь же эффективной, как результат выполнения упражнения 2. В ходе дальнейшей работы над «Доктором» всякий раз, когда описываете обработку списка, сделайте это с помощью подходящих функций высшего порядка (***map***, ***foldl***, ***foldr***, ***filter***, ***andmap***, ***ormap*** ...). В модуле, подключаемом директивой `(require racket/list)` есть дополнительные функции высшего порядка для работы со списками (***filter-map***, ***count***, ***append-map***, ***filter-not***, ***argmin***, ***argmax***, ***remf***, ***remf****, ...), имейте это в виду. Также обратите внимание на то, что имеются библиотечные реализации операций над списками вроде поиска вхождения элемента, получения префикса списка или окончания списка. Не делайте их собственных реализаций, используйте готовые. Доки Вам в помощь. При дальнейшей работе над «Доктором» Вы столкнётесь с ситуациями, когда обработка списка такова, что в лучшем случае результат становится известен до окончания прохода по всему списку. В таких случаях (если нет подходящей функции высшего порядка) используйте ***call/cc*** для досрочного выхода из цикла обработки.

Все описанные требования в отношении списков касаются также обработки векторов. Всякий раз, когда описываете обработку вектора, сделайте это с помощью подходящих функций высшего порядка (***vector-map***, ***vector-foldl***, ***vector-foldr***, ***vector-filter***, ...). В модуле, подключаемом директивой (`require racket/vector`) есть дополнительные функции высшего порядка для работы с векторами (***vector-argmin***, ***vector-argmax***, ***vector-filter-not***, ...), имейте это в виду. Имеются библиотечные реализации операций над векторами вроде поиска вхождения элемента, получения префикса вектора или окончания вектора. Не делайте их собственных реализаций, используйте готовые. Когда обработка вектора такова, что в лучшем случае результат становится известен до окончания прохода по всему списку, и нет подходящей функции высшего порядка, используйте ***call/cc*** для досрочного выхода из цикла обработки вектора.
***Никогда не используйте перевод векторов в списки, и списков в вектора***. Обработка векторов должна осуществляться векторными функциями, а обработка списков -- списочными. Реализацию свёртки для вектора возьмите из заготовки кода «Доктора».

### Упражнение 4. 3-я стратегия генерации ответов

Двух способов генерации ответов мало. Добавим третий. «Доктор» может запоминать последние 7 реплик пациента и в ходе беседы возвращаться к сказанному пациентом ранее. В этом случае реплика «Доктора» будет начинаться со слов *"earlier you said that"*, а затем будет следовать одна из запомненных предыдущих реплик пациента, в которой выполнена замена лица. Например, если из предыдущих реплик пациента выбрана реплика *(you are not being very helpful to me)*, то по ней будет построен ответ *(earlier you said that i am not being very helpful to you)*.

#### Задание упражнения 4. 
Измените программу таким образом, чтобы ***doctor-driver-loop-v2*** сохранял вектор из 7 предыдущих различных реплик пользователя. В начале сеанса этот вектор будет пуст. Потом в него будет добавлена первая реплика, затем вторая и т. д.. Всякий раз очередная реплика будет сначала проверена на то, не хранится ли точно такая же реплика в векторе. Если реплика новая, то она будет добавляться в начало вектора. При добавлении восьмой новой реплики из вектора исключается реплика, добавленная первой, и т. д.. Получится, что длина вектора реплик не будет превосходить 7. ***Замечание: не используйте присваивания (мутаторы вроде set!, vector-set!). В этом нет необходимости.*** 

Новая версия функции ***reply*** будет выбирать одну стратегию из трёх. Новую стратегию реализуйте как отдельную функцию ***history-answer***. Обратите внимание, что ***hedge-answer*** и ***qualifier-answer*** можно применять всегда, а ***history-answer*** -- только при наличии не менее чем одной запомненной реплики. Когда пациент лишь вводит первую реплику, тогда эта стратегия не применима. Учтите это в реализации. Для случайного выбора из ***N (=3)*** альтернатив следует взять случайное число от ***0*** до ***N-1***: `(random 0 N)`, и использовать его как номер выбранной стратегии, считая, что они нумеруются с нуля. Количество применимых стратегий построения ответа зависит от того, пуста ли история или не пуста. Отразите это в своём коде. Для вызова стратегии по выбранному номеру подходит ***спецформа case***.